### 可变字节详述

Varints 是使用哦一个或多个字节来序列化整数的一种方法。数值越小，其占用的字节数就越少。Varints 中的每个字节都一个位于最高位的 msb 位(most
significant bit), 除最后一个字节外，其余 msb 位都设置为 1，最后一个字节的 msb 位为0。这个 msb 位的表示其后的字节是否和当前字节一起来表示
同一个整数(就是标识一个整数的字节结束)。除 msb 外，剩余的 7 位用于存储数据本身，这种表示类型又称为 Base 128。通常而言，一个字节 8 位可以表示 256 个值
所以成为 Base 256，而这里只能用 7 位表示，2^7=128。Varints 中采用的是小端字节序，即最小的字节放在最前面。
举个栗子，比如数字 1 ，它只占用一个字节，所以 msb 位为 0：
0000 0001
再举个复杂的例子，比如说数字 300：
1010 1100 0000 0010
300 的二进制原本为 0000 0001 0010 1100 = 256 + 32 + 8 +4 = 300, 那么为什么 300 的变成表示为上面的这种形式那？
0000 0001 0010 1100
-> 00 000 0010 010 1100 每个字节取低 7 位
-> 1(msb)010 1100 0(msb)000 0010   反转并实现小端字节序列-小的字节放前面，并 msb 高7位为 1 ，最后 7 位为 0。最前面的 2 个 0 表示为 0，
因为没有 1 ，会被变为认为 0 字节，也就是没有字节可读被舍去，相当于前面补0，没有实际意义
-> 1010 1100 0000 0010 最终编码的值

反编码的过程就是把这个过程倒过来。
1010 1100 0000 0010
-> 010 1100 000 0010 （去掉每个字节的 msb 位）
-> 000 0010 010 1100 （翻转)
-> 1 0010 1100 （还原为真实的二进制)
-> 0000 0001 0010 1100 = 256 + 32 + 8 + 4 (格式化一下)
至此，varint 的编码理论的已经描述完毕。

### ZigZag 编码 

Varints 可以用来表示 int32,int64,unint32、unint64、sint32、sint64、bool、enum 等类型。
在实际使用过程中，如果当期那字段可以表示为负数，那么对 int32/int64 和 sint32/sint64 而言，它们在进行编码的时候存在较大的区别。比如使用 int64 表示一个负数，哪怕是 -1，其编码后的长度始终为 10 个字节，具体测试方法请参见 varintTest.sizeOfLong 方法，就如同对待一个很大的无符号长整数一样。为了使编码更加高效，Varints 使用了 ZigZag 的编码方式。

ZigZag 编码是以一种锯齿形(zig-zags)的方式来回穿梭正负数，将带符号的映射为无符号的整数，这样可以使绝对值较小的负数仍然享有较小的 Varints 编码，比如 -1 编码为 1,1 编码为 2，-2 编码为 3,2 编码为 4。如下表所示

| 原值        | 编码后的值 |
| ----------- | ---------- |
| 0           | 0          |
| -1          | 1          |
| 1           | 2          |
| -2          | 3          |
| 2147483647  | 4294967294 |
| -2147483648 | 4294967295 |

对 sint32 而言，该编码的公式为 ：

> (n << 1) ^ (n >> 31)

sint64 对应的公式为 

> (n << 1) ^ (n >> 63)

以 -1 为例，其二进制表现形式为 1111 1111 1111 1111 1111 1111 1111 1111 (补码)。
n << 1   = 1111 1111 1111 1111 1111 1111 1111 1110
n >> 31  = 1111 1111 1111 1111 1111 1111 1111 1111 (有符号右移)
n >>> 31 = 0000 0000 0000 0000 0000 0000 0000 0001 (无符号右移)
(n << 1) ^ (n >> 31) = 1

最终 -1 的 Varints 被编码为 0000 0001，这样原本用 4 字节表示的 -1 现在可以用 1 个字节来表示了。
1 的 zigzag 编码就显得非常简单了，如下所示
1 << 1   = 0000 0000 0000 0000 0000 0000 0000 0010
1 >> 31  = 0000 0000 0000 0000 0000 0000 0000 0000 (有符号右移)
(n << 1) ^ (n >> 31) = 2

最终 1 的 Varints 编码为 0000 0010 ，也是只占用 1 个字节。前面说过 Varints 中的一个字节只有 7 位是有效数值，即只能表示 128 个数值(0-127)，转变成绝对值之后其实只能表示 65 个数值(0-64)。比如对消息体长度而言，其数值肯定是大于 0 的正整数，那么一个字节长度的 Varints 最大只能表示 63。64 的二进制表示为：
0100 0000，经过 zigzag 编码后为
1000 0000 ^ 0000 0000 = 1000 0000

每个字节的低 7 位是有效数值，所以 1000 0000 进一步转变成：

000 0001 000 0000

Varints 使用 小端编码，需要反转一下位置

000 0000 000 0001

设置非最优一个字节的 msb 位为 1，最优一个字节的 msb 位为 0 ，最终有：

1000 0000 0000 0001

最终 64 编码为 1000 0000 0000 0001。 而 63 或者 -64 被编码为如下结果：
63 的二进制为 0011 1111，经过 zigzag 编码后为:

(n << 1) ^ (n >> 31) = 0111 1110 ^ 0000 0000 = 0111 1110

0111 1110
-> 0 111 1110 (7 字节)
-> 0 111 1110 (只有 7 字节 不需要反转，msb 为0，仍然是本身)


同理，-64 被zigzag 编码后：
-64 == ~63 == 1111 1111 1111 1111 1111 1111 1100 0000
(n << 1) ^ (n >> 31) = 
1111 1111 1111 1111 1111 1111 1000 0000 ^ 1111 1111 1111 1111 1111 1111 1111 1111 =111 1111 = 127
在经过 varint 编码：
0111 1111 = 127

#### 结论：
也就是说 64 被编码成 1000 0000 0000 0001，是双字节；而 -64 被编码成 0111 1111，63 被编码成 0111 1110，是单字节

如果消息格式中长度有关的字段采用 varints 编码，那么绝大多数的情况下都会节省空间。

不过需要注意的是，Varints 并非一直会节省空间，一个 int32 最长会占用 5 个字节(大于默认的 4 个字节)，一个 int64 最长会占用 10 个字节(大于默认的 8 个字节)。sizeOfVarint() 方法展示了如何计算一个 int32 占用的字节数：
